<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Battle Wars â€“ Standalone</title>
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="min-h-screen bg-sky-50">
    <div id="root"></div>

    <!-- React 18 via CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel to allow JSX in the browser (for quick demo). For production, use a bundler. -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
      const { useMemo, useState, useEffect } = React;

      // --- Simple Advance Wars-like tactics game in a single file ---
      const W = 12; // columns
      const H = 8;  // rows

      const TERRAIN = {
        PLAINS: { key: "PLAINS", name: "Plains", moveCost: 1, defense: 0, emoji: "Â·" },
        FOREST: { key: "FOREST", name: "Forest", moveCost: 2, defense: 1, emoji: "ğŸŒ²" },
        ROAD:   { key: "ROAD",   name: "Road",   moveCost: 1, defense: 0, emoji: "â”€" },
        CITY:   { key: "CITY",   name: "City",   moveCost: 1, defense: 2, emoji: "ğŸ™ï¸" },
        MOUNTAIN:{key:"MOUNTAIN",name:"Mountain",moveCost: 999, defense: 3, emoji: "â›°ï¸"},
      };

      const TERRAIN_KEYS = Object.keys(TERRAIN);
      const mkTile = (key) => ({ ...TERRAIN[key] });

      // Map definition (.=plains, F=forest, R=road, C=city, M=mountain)
      const MAP_STR = [
        "..F...R..C..",
        ".F..M....F..",
        "..R..F..C...",
        "....F....M..",
        "..C..R..F...",
        "..M....F..R.",
        "..F..C....F.",
        "C..R...F..M.",
      ];

      function parseMap() {
        const grid = [];
        for (let y = 0; y < H; y++) {
          const row = [];
          for (let x = 0; x < W; x++) {
            const ch = MAP_STR[y][x] || ".";
            let key = "PLAINS";
            if (ch === ".") key = "PLAINS";
            else if (ch === "F") key = "FOREST";
            else if (ch === "R") key = "ROAD";
            else if (ch === "C") key = "CITY";
            else if (ch === "M") key = "MOUNTAIN";
            row.push({ x, y, ...mkTile(key) });
          }
          grid.push(row);
        }
        return grid;
      }

      // Unit templates
      const UNIT_TYPES = {
        INF: {
          key: "INF",
          name: "Infantry",
          move: 3,
          minRange: 1,
          maxRange: 1,
          emoji: "ğŸ‘¤",
          atk: { INF: 55, TANK: 25, ARTY: 45 },
        },
        TANK: {
          key: "TANK",
          name: "Tank",
          move: 5,
          minRange: 1,
          maxRange: 1,
          emoji: "ğŸ›¡ï¸",
          atk: { INF: 85, TANK: 55, ARTY: 90 },
        },
        ARTY: {
          key: "ARTY",
          name: "Artillery",
          move: 2,
          minRange: 2,
          maxRange: 3,
          emoji: "ğŸ¯",
          atk: { INF: 70, TANK: 45, ARTY: 75 },
        },
      };

      const TEAM = {
        RED:  { key: "RED",  name: "Red",  color: "#ef4444" },
        BLUE: { key: "BLUE", name: "Blue", color: "#3b82f6" },
      };

      let idCounter = 1;
      function mkUnit({ type, team, x, y }) {
        const t = UNIT_TYPES[type];
        return { id: idCounter++, type: t.key, team: team.key, x, y, hp: 10, moved: false, acted: false };
      }

      function initialUnits() {
        const u = [];
        // Red (top-left)
        u.push(mkUnit({ type: "INF",  team: TEAM.RED,  x: 0,     y: 0 }));
        u.push(mkUnit({ type: "TANK", team: TEAM.RED,  x: 1,     y: 1 }));
        u.push(mkUnit({ type: "ARTY", team: TEAM.RED,  x: 2,     y: 0 }));
        // Blue (bottom-right)
        u.push(mkUnit({ type: "INF",  team: TEAM.BLUE, x: W - 1, y: H - 1 }));
        u.push(mkUnit({ type: "TANK", team: TEAM.BLUE, x: W - 2, y: H - 2 }));
        u.push(mkUnit({ type: "ARTY", team: TEAM.BLUE, x: W - 3, y: H - 1 }));
        return u;
      }

      // Helpers
      const inBounds = (x, y) => x >= 0 && y >= 0 && x < W && y < H;
      const keyXY = (x, y) => `${x},${y}`;
      const manhattan = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
      const unitAt = (units, x, y) => units.find((u) => u.x === x && u.y === y);
      const cloneUnits = (units) => units.map((u) => ({ ...u }));
      const teamUnits = (units, teamKey) => units.filter((u) => u.team === teamKey);
      const enemyUnits = (units, teamKey) => units.filter((u) => u.team !== teamKey);
      const getTerrain = (grid, x, y) => grid[y][x];

      // BFS to compute reachable tiles
      function computeReachable(grid, units, from, movePoints, teamKey) {
        const frontier = [{ x: from.x, y: from.y, cost: 0 }];
        const visited = new Map();
        visited.set(keyXY(from.x, from.y), 0);
        const occupied = new Set(units.map((u) => keyXY(u.x, u.y)));

        while (frontier.length) {
          const cur = frontier.shift();
          const dirs = [ [1,0],[-1,0],[0,1],[0,-1] ];
          for (const [dx, dy] of dirs) {
            const nx = cur.x + dx, ny = cur.y + dy;
            if (!inBounds(nx, ny)) continue;
            const tile = getTerrain(grid, nx, ny);
            if (tile.moveCost >= 999) continue; // impassable
            const nextCost = cur.cost + tile.moveCost;
            if (nextCost > movePoints) continue;
            const k = keyXY(nx, ny);
            const prev = visited.get(k);
            if (occupied.has(k) && !(nx === from.x && ny === from.y)) continue;
            if (prev == null || nextCost < prev) {
              visited.set(k, nextCost);
              frontier.push({ x: nx, y: ny, cost: nextCost });
            }
          }
        }
        visited.delete(keyXY(from.x, from.y));
        return visited; // Map<"x,y", cost>
      }

      function tilesInRange(from, minR, maxR) {
        const res = [];
        for (let y = 0; y < H; y++) {
          for (let x = 0; x < W; x++) {
            const d = Math.abs(from.x - x) + Math.abs(from.y - y);
            if (d >= minR && d <= maxR) res.push({ x, y });
          }
        }
        return res;
      }

      function calcDamage(attacker, defender, grid) {
        const atkType = UNIT_TYPES[attacker.type];
        const defType = UNIT_TYPES[defender.type];
        const base = atkType.atk[defender.type] ?? 40;
        const attackHP = attacker.hp; // 0..10
        const terrainDef = getTerrain(grid, defender.x, defender.y).defense;
        const reduction = Math.max(0, 1 - 0.05 * terrainDef);
        const dmgPct = Math.round((base * (attackHP / 10)) * reduction);
        const hpLoss = Math.min(10, Math.max(1, Math.round(dmgPct / 10)));
        return hpLoss;
      }

      function endTurnRefresh(units, teamKey) {
        return units.map((u) => (u.team === teamKey ? { ...u, moved: false, acted: false } : u));
      }

      function removeDead(units) { return units.filter((u) => u.hp > 0); }

      function UnitBadge({ u }) {
        const t = UNIT_TYPES[u.type];
        const color = u.team === TEAM.RED.key ? TEAM.RED.color : TEAM.BLUE.color;
        const acted = u.acted ? "opacity-50" : "";
        return (
          <div className={`absolute inset-0 flex items-center justify-center ${acted}`}>
            <div className="flex flex-col items-center">
              <div className="rounded-full px-2 py-1 text-white text-xs" style={{ backgroundColor: color }}>
                {t.emoji}
              </div>
              <div className="mt-1 text-[10px] md:text-xs font-semibold">HP {u.hp}</div>
            </div>
          </div>
        );
      }

      function Sidebar({ selected, units, turn, onEndTurn, winner, onReset }) {
        const myUnits = teamUnits(units, turn).length;
        const enemy = enemyUnits(units, turn).length;
        return (
          <div className="w-full md:w-64 p-3 md:p-4 bg-white/70 backdrop-blur rounded-2xl shadow space-y-3">
            <div className="flex items-center justify-between">
              <div className="text-sm md:text-base font-bold">Turn: <span className="px-2 py-0.5 rounded text-white" style={{backgroundColor: turn===TEAM.RED.key?TEAM.RED.color:TEAM.BLUE.color}}>{turn}</span></div>
              <button onClick={onReset} className="text-xs md:text-sm px-2 py-1 rounded-lg border hover:bg-slate-50">Reset</button>
            </div>
            {winner ? (
              <div className="p-3 rounded-xl bg-lime-100 text-lime-900 font-semibold">Winner: {winner}</div>
            ) : (
              <button onClick={onEndTurn} className="w-full px-3 py-2 rounded-xl bg-indigo-600 text-white font-semibold hover:bg-indigo-700">End Turn</button>
            )}

            <div className="grid grid-cols-2 gap-2 text-xs">
              <div className="p-2 rounded-lg bg-red-50">Red: {turn===TEAM.RED.key?"(active) ":""}{turn===TEAM.RED.key?myUnits:enemy}</div>
              <div className="p-2 rounded-lg bg-blue-50">Blue: {turn===TEAM.BLUE.key?"(active) ":""}{turn===TEAM.BLUE.key?myUnits:enemy}</div>
            </div>

            <div className="text-sm md:text-base font-semibold">Selected</div>
            {selected ? (
              <div className="text-xs md:text-sm p-2 rounded-xl bg-slate-100 space-y-1">
                <div><b>{selected.team}</b> {UNIT_TYPES[selected.type].name}</div>
                <div>HP: {selected.hp}</div>
                <div>Move: {UNIT_TYPES[selected.type].move}</div>
                <div>Range: {UNIT_TYPES[selected.type].minRange}â€“{UNIT_TYPES[selected.type].maxRange}</div>
                <div>Status: {selected.acted ? "Done" : selected.moved ? "Moved" : "idle"}</div>
                <div>Pos: ({selected.x},{selected.y})</div>
                <div className="text-[11px] text-slate-600">Tip: ç§»å‹•å¾Œã«æ•µãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨æ”»æ’ƒã—ã¾ã™ã€‚ç©ºãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨è¡Œå‹•çµ‚äº†ã€‚</div>
              </div>
            ) : (
              <div className="text-xs md:text-sm p-2 rounded-xl bg-slate-50 text-slate-600">ãƒ¦ãƒ‹ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„</div>
            )}

            <div className="text-sm md:text-base font-semibold">Terrain</div>
            <div className="grid grid-cols-2 gap-2 text-xs">
              {TERRAIN_KEYS.map((k) => (
                <div key={k} className="p-2 rounded-lg bg-slate-50 flex items-center justify-between">
                  <span>{TERRAIN[k].name}</span>
                  <span className="text-slate-500">{TERRAIN[k].emoji}</span>
                </div>
              ))}
            </div>
          </div>
        );
      }

      function BattleWarsLike() {
        const grid = useMemo(parseMap, []);
        const [units, setUnits] = useState(initialUnits);
        const [turn, setTurn] = useState(TEAM.RED.key);
        const [selectedId, setSelectedId] = useState(null);
        const [reachable, setReachable] = useState(new Map());
        const [phase, setPhase] = useState("idle");
        const [winner, setWinner] = useState(null);

        useEffect(() => {
          const redLeft = teamUnits(units, TEAM.RED.key).length;
          const blueLeft = teamUnits(units, TEAM.BLUE.key).length;
          if (redLeft === 0) setWinner(TEAM.BLUE.key);
          else if (blueLeft === 0) setWinner(TEAM.RED.key);
        }, [units]);

        const selected = units.find((u) => u.id === selectedId) || null;

        function onTileClick(x, y) {
          if (winner) return;
          const u = unitAt(units, x, y);

          if (phase === "idle") {
            if (u && u.team === turn && !u.acted) {
              setSelectedId(u.id);
              const t = UNIT_TYPES[u.type];
              const reach = computeReachable(grid, units, u, t.move, turn);
              setReachable(reach);
              setPhase("moving");
            } else {
              setSelectedId(null);
              setReachable(new Map());
            }
            return;
          }

          if (phase === "moving" && selected) {
            const k = keyXY(x, y);
            const occupied = unitAt(units, x, y);
            if (reachable.has(k) && !occupied) {
              const next = cloneUnits(units);
              const me = next.find((uu) => uu.id === selected.id);
              me.x = x; me.y = y; me.moved = true;
              setUnits(next);
              setSelectedId(me.id);
              setPhase("targeting");
            } else if (u && u.id === selected.id) {
              setPhase("idle");
              setSelectedId(null);
              setReachable(new Map());
            }
            return;
          }

          if (phase === "targeting" && selected) {
            if (u && u.team !== turn) {
              const atkType = UNIT_TYPES[selected.type];
              const d = Math.abs(selected.x - u.x) + Math.abs(selected.y - u.y);
              if (d >= atkType.minRange && d <= atkType.maxRange) {
                const next = cloneUnits(units);
                const me = next.find((uu) => uu.id === selected.id);
                const foe = next.find((uu) => uu.id === u.id);
                const dmg = calcDamage(me, foe, grid);
                foe.hp = Math.max(0, foe.hp - dmg);
                me.acted = true;
                setUnits(removeDead(next));
                setSelectedId(null);
                setReachable(new Map());
                setPhase("idle");
                return;
              }
            }
            const next = cloneUnits(units);
            const me = next.find((uu) => uu.id === selected.id);
            if (me) me.acted = true;
            setUnits(next);
            setSelectedId(null);
            setReachable(new Map());
            setPhase("idle");
          }
        }

        function endTurn() {
          if (winner) return;
          const nextTeam = turn === TEAM.RED.key ? TEAM.BLUE.key : TEAM.RED.key;
          setUnits((prev) => endTurnRefresh(prev, nextTeam));
          setTurn(nextTeam);
          setSelectedId(null);
          setReachable(new Map());
          setPhase("idle");
        }

        function resetGame() {
          idCounter = 1;
          setUnits(initialUnits());
          setTurn(TEAM.RED.key);
          setSelectedId(null);
          setReachable(new Map());
          setPhase("idle");
          setWinner(null);
        }

        const highlight = useMemo(() => new Set(Array.from(reachable.keys())), [reachable]);

        function tileClasses(x, y) {
          const tile = grid[y][x];
          const u = unitAt(units, x, y);
          const isReach = highlight.has(keyXY(x, y)) && !u;
          const base = "relative flex items-center justify-center border border-gray-200 text-xs md:text-sm select-none";
          const size = "w-10 h-10 md:w-14 md:h-14";
          let bg = "bg-emerald-50";
          if (tile.key === "FOREST") bg = "bg-green-200";
          if (tile.key === "ROAD") bg = "bg-yellow-100";
          if (tile.key === "CITY") bg = "bg-slate-200";
          if (tile.key === "MOUNTAIN") bg = "bg-stone-300";
          const hover = "hover:ring-2 hover:ring-indigo-400";
          const reach = isReach ? "ring-2 ring-indigo-500" : "";
          return `${base} ${size} ${bg} ${hover} ${reach}`;
        }

        return (
          <div className="min-h-screen w-full bg-gradient-to-b from-sky-50 to-slate-100 p-3 md:p-6">
            <div className="mx-auto max-w-6xl grid grid-cols-1 md:grid-cols-[1fr_260px] gap-4">
              <div className="rounded-2xl bg-white p-2 md:p-4 shadow">
                <div className="text-base md:text-lg font-bold mb-2 md:mb-3">Battle Wars â€“ Mini</div>
                <div className="grid" style={{ gridTemplateColumns: `repeat(${W}, minmax(0,1fr))` }}>
                  {Array.from({ length: H }).map((_, y) => (
                    <React.Fragment key={`row-${y}`}>
                      {Array.from({ length: W }).map((__, x) => {
                        const u = unitAt(units, x, y);
                        const t = grid[y][x];
                        return (
                          <div
                            key={`t-${x}-${y}`}
                            className={tileClasses(x, y)}
                            onClick={() => onTileClick(x, y)}
                            title={`${t.name}  DEF+${t.defense}  MC${t.moveCost}`}
                          >
                            <div className="absolute left-1 top-1 text-[10px] text-slate-500">{t.emoji}</div>
                            {u && <UnitBadge u={u} />}
                          </div>
                        );
                      })}
                    </React.Fragment>
                  ))}
                </div>
                <div className="mt-3 text-xs md:text-sm text-slate-600">
                  ä½¿ã„æ–¹ï¼šè‡ªè»ï¼ˆã‚¿ãƒ¼ãƒ³è¡¨ç¤ºã®è‰²ï¼‰ã®ãƒ¦ãƒ‹ãƒƒãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ â†’ é’ã„ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ãƒã‚¹ã¸ç§»å‹• â†’ æ•µãƒ¦ãƒ‹ãƒƒãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ã§æ”»æ’ƒ â†’ ã€ŒEnd Turnã€ã§ç›¸æ‰‹ã¸äº¤ä»£ã€‚
                </div>
              </div>

              <Sidebar
                selected={selected}
                units={units}
                turn={turn}
                onEndTurn={endTurn}
                winner={winner}
                onReset={resetGame}
              />
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<BattleWarsLike />);
    </script>
  </body>
</html>
