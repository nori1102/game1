import React, { useMemo, useState, useEffect } from "react";

// --- Simple Advance Wars-like tactics game in a single React file ---
// - Two teams: Red vs Blue
// - Units have movement points, attack ranges, and simple damage rules
// - Click your unit â†’ highlight moves â†’ click destination â†’ choose attack (if available)
// - End Turn button passes control and refreshes unit actions
// - Win when the enemy has no units

// ====== DATA ======
const W = 12; // columns
const H = 8;  // rows

const TERRAIN = {
  PLAINS: { key: "PLAINS", name: "Plains", moveCost: 1, defense: 0, emoji: "Â·" },
  FOREST: { key: "FOREST", name: "Forest", moveCost: 2, defense: 1, emoji: "ğŸŒ²" },
  ROAD:   { key: "ROAD",   name: "Road",   moveCost: 1, defense: 0, emoji: "â”€" },
  CITY:   { key: "CITY",   name: "City",   moveCost: 1, defense: 2, emoji: "ğŸ™ï¸" },
  MOUNTAIN:{key:"MOUNTAIN",name:"Mountain",moveCost: 999, defense: 3, emoji: "â›°ï¸"},
};

const TERRAIN_KEYS = Object.keys(TERRAIN);

const mkTile = (key) => ({ ...TERRAIN[key] });

// A light, readable map (H rows of W cols). 
// Use characters to define terrain more easily
// . = plains, F = forest, R = road, C = city, M = mountain
const MAP_STR = [
  "..F...R..C..",
  ".F..M....F..",
  "..R..F..C...",
  "....F....M..",
  "..C..R..F...",
  "..M....F..R.",
  "..F..C....F.",
  "C..R...F..M.",
];

function parseMap() {
  const grid = [];
  for (let y = 0; y < H; y++) {
    const row = [];
    for (let x = 0; x < W; x++) {
      const ch = MAP_STR[y][x] || ".";
      let key = "PLAINS";
      if (ch === ".") key = "PLAINS";
      else if (ch === "F") key = "FOREST";
      else if (ch === "R") key = "ROAD";
      else if (ch === "C") key = "CITY";
      else if (ch === "M") key = "MOUNTAIN";
      row.push({ x, y, ...mkTile(key) });
    }
    grid.push(row);
  }
  return grid;
}

// Unit templates
const UNIT_TYPES = {
  INF: {
    key: "INF",
    name: "Infantry",
    move: 3,
    minRange: 1,
    maxRange: 1,
    emoji: "ğŸ‘¤",
    // base damage vs target type
    atk: { INF: 55, TANK: 25, ARTY: 45 },
  },
  TANK: {
    key: "TANK",
    name: "Tank",
    move: 5,
    minRange: 1,
    maxRange: 1,
    emoji: "ğŸ›¡ï¸",
    atk: { INF: 85, TANK: 55, ARTY: 90 },
  },
  ARTY: {
    key: "ARTY",
    name: "Artillery",
    move: 2,
    minRange: 2,
    maxRange: 3,
    emoji: "ğŸ¯",
    atk: { INF: 70, TANK: 45, ARTY: 75 },
  },
};

const TEAM = {
  RED: { key: "RED", name: "Red", color: "#ef4444" },
  BLUE:{ key: "BLUE",name: "Blue",color: "#3b82f6" },
};

let idCounter = 1;
function mkUnit({ type, team, x, y }) {
  const t = UNIT_TYPES[type];
  return {
    id: idCounter++,
    type: t.key,
    team: team.key,
    x, y,
    hp: 10, // 10 = 100%
    moved: false,
    acted: false,
  };
}

function initialUnits() {
  const u = [];
  // Red side (top-left)
  u.push(mkUnit({ type: "INF", team: TEAM.RED, x: 0, y: 0 }));
  u.push(mkUnit({ type: "TANK", team: TEAM.RED, x: 1, y: 1 }));
  u.push(mkUnit({ type: "ARTY", team: TEAM.RED, x: 2, y: 0 }));
  // Blue side (bottom-right)
  u.push(mkUnit({ type: "INF", team: TEAM.BLUE, x: W - 1, y: H - 1 }));
  u.push(mkUnit({ type: "TANK", team: TEAM.BLUE, x: W - 2, y: H - 2 }));
  u.push(mkUnit({ type: "ARTY", team: TEAM.BLUE, x: W - 3, y: H - 1 }));
  return u;
}

// ====== HELPERS ======
function inBounds(x, y) {
  return x >= 0 && y >= 0 && x < W && y < H;
}

function key(x, y) { return `${x},${y}`; }

function manhattan(a, b) { return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); }

function unitAt(units, x, y) {
  return units.find((u) => u.x === x && u.y === y);
}

function cloneUnits(units) {
  return units.map((u) => ({ ...u }));
}

function teamUnits(units, teamKey) {
  return units.filter((u) => u.team === teamKey);
}

function enemyUnits(units, teamKey) {
  return units.filter((u) => u.team !== teamKey);
}

function getTerrain(grid, x, y) { return grid[y][x]; }

// BFS to compute reachable tiles given movement points and blocking units/impassable terrain
function computeReachable(grid, units, from, movePoints, teamKey) {
  const frontier = [{ x: from.x, y: from.y, cost: 0 }];
  const visited = new Map();
  visited.set(key(from.x, from.y), 0);
  const occupied = new Set(units.map((u) => key(u.x, u.y)));

  while (frontier.length) {
    const cur = frontier.shift();
    const dirs = [ [1,0],[-1,0],[0,1],[0,-1] ];
    for (const [dx, dy] of dirs) {
      const nx = cur.x + dx, ny = cur.y + dy;
      if (!inBounds(nx, ny)) continue;
      const tile = getTerrain(grid, nx, ny);
      if (tile.moveCost >= 999) continue; // impassable
      const nextCost = cur.cost + tile.moveCost;
      if (nextCost > movePoints) continue;
      const k = key(nx, ny);
      const prev = visited.get(k);
      // cannot move through other units, but you may END on empty tiles only
      if (occupied.has(k) && !(nx === from.x && ny === from.y)) continue;
      if (prev == null || nextCost < prev) {
        visited.set(k, nextCost);
        frontier.push({ x: nx, y: ny, cost: nextCost });
      }
    }
  }
  // All keys in visited are reachable; remove the origin for display purposes
  visited.delete(key(from.x, from.y));
  return visited; // Map<"x,y", cost>
}

function tilesInRange(from, minR, maxR) {
  const res = [];
  for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
      const d = Math.abs(from.x - x) + Math.abs(from.y - y);
      if (d >= minR && d <= maxR) res.push({ x, y });
    }
  }
  return res;
}

function calcDamage(attacker, defender, grid) {
  const atkType = UNIT_TYPES[attacker.type];
  const defType = UNIT_TYPES[defender.type];
  const base = atkType.atk[defType.key] ?? 40;
  const attackHP = attacker.hp; // scale with hp (0-10)
  const terrainDef = getTerrain(grid, defender.x, defender.y).defense;
  // Simple formula similar in spirit to Advance Wars: damage% = base * (HP/10) * (1 - 0.05*def)
  const reduction = Math.max(0, 1 - 0.05 * terrainDef);
  const dmgPct = Math.round((base * (attackHP / 10)) * reduction);
  // Convert percent-of-10HP to HP damage (out of 10). Clamp 0..10.
  const hpLoss = Math.min(10, Math.max(1, Math.round(dmgPct / 10)));
  return hpLoss;
}

function endTurnRefresh(units, teamKey) {
  return units.map((u) => {
    if (u.team === teamKey) return { ...u, moved: false, acted: false };
    return u;
  });
}

function removeDead(units) {
  return units.filter((u) => u.hp > 0);
}

// ====== UI COMPONENT ======
export default function BattleWarsLike() {
  const grid = useMemo(parseMap, []);
  const [units, setUnits] = useState(initialUnits);
  const [turn, setTurn] = useState(TEAM.RED.key);
  const [selectedId, setSelectedId] = useState(null);
  const [reachable, setReachable] = useState(new Map());
  const [phase, setPhase] = useState("idle"); // idle | moving | targeting
  const [moveFrom, setMoveFrom] = useState(null);
  const [moveTo, setMoveTo] = useState(null);
  const [winner, setWinner] = useState(null);

  useEffect(() => {
    const redLeft = teamUnits(units, TEAM.RED.key).length;
    const blueLeft = teamUnits(units, TEAM.BLUE.key).length;
    if (redLeft === 0) setWinner(TEAM.BLUE.key);
    else if (blueLeft === 0) setWinner(TEAM.RED.key);
  }, [units]);

  const selected = units.find((u) => u.id === selectedId) || null;

  function onTileClick(x, y) {
    if (winner) return;
    const u = unitAt(units, x, y);

    // Selecting a unit
    if (phase === "idle") {
      if (u && u.team === turn && !u.acted) {
        setSelectedId(u.id);
        const t = UNIT_TYPES[u.type];
        const reach = computeReachable(grid, units, u, t.move, turn);
        setReachable(reach);
        setPhase("moving");
        setMoveFrom({ x: u.x, y: u.y });
      } else {
        // Clicked empty tile or enemy â†’ clear selection
        setSelectedId(null);
        setReachable(new Map());
      }
      return;
    }

    // Moving phase â€“ click on a reachable empty tile to move
    if (phase === "moving" && selected) {
      const k = key(x, y);
      const occupied = unitAt(units, x, y);
      if (reachable.has(k) && !occupied) {
        // perform move
        const next = cloneUnits(units);
        const me = next.find((uu) => uu.id === selected.id);
        me.x = x; me.y = y; me.moved = true;
        setUnits(next);
        setSelectedId(me.id);
        setMoveTo({ x, y });
        setPhase("targeting");
        // In targeting phase, we keep selection and show attackables
      } else if (u && u.id === selected.id) {
        // Re-click original unit to cancel
        setPhase("idle");
        setSelectedId(null);
        setReachable(new Map());
      }
      return;
    }

    // Targeting phase â€“ click enemy in range to attack, or empty tile to finish
    if (phase === "targeting" && selected) {
      if (u && u.team !== turn) {
        const atkType = UNIT_TYPES[selected.type];
        const d = manhattan(selected, u);
        if (d >= atkType.minRange && d <= atkType.maxRange) {
          // Attack!
          const next = cloneUnits(units);
          const me = next.find((uu) => uu.id === selected.id);
          const foe = next.find((uu) => uu.id === u.id);
          const dmg = calcDamage(me, foe, grid);
          foe.hp = Math.max(0, foe.hp - dmg);
          me.acted = true;
          setUnits(removeDead(next));
          setSelectedId(null);
          setReachable(new Map());
          setPhase("idle");
          return;
        }
      }
      // If clicked elsewhere, just finish action without attacking
      const next = cloneUnits(units);
      const me = next.find((uu) => uu.id === selected.id);
      if (me) me.acted = true;
      setUnits(next);
      setSelectedId(null);
      setReachable(new Map());
      setPhase("idle");
    }
  }

  function endTurn() {
    if (winner) return;
    const nextTeam = turn === TEAM.RED.key ? TEAM.BLUE.key : TEAM.RED.key;
    setUnits((prev) => endTurnRefresh(prev, nextTeam));
    setTurn(nextTeam);
    setSelectedId(null);
    setReachable(new Map());
    setPhase("idle");
  }

  function resetGame() {
    idCounter = 1;
    setUnits(initialUnits());
    setTurn(TEAM.RED.key);
    setSelectedId(null);
    setReachable(new Map());
    setPhase("idle");
    setWinner(null);
  }

  // Derived UI helpers
  const highlight = useMemo(() => {
    const set = new Set();
    for (const k of reachable.keys()) set.add(k);
    return set;
  }, [reachable]);

  function tileClasses(x, y) {
    const tile = grid[y][x];
    const k = key(x, y);
    const u = unitAt(units, x, y);
    const isReach = highlight.has(k) && !u;
    const base = "relative flex items-center justify-center border border-gray-200 text-xs md:text-sm select-none";
    const size = "w-10 h-10 md:w-14 md:h-14";
    let bg = "bg-emerald-50"; // plains default
    if (tile.key === "FOREST") bg = "bg-green-200";
    if (tile.key === "ROAD") bg = "bg-yellow-100";
    if (tile.key === "CITY") bg = "bg-slate-200";
    if (tile.key === "MOUNTAIN") bg = "bg-stone-300";
    const hover = "hover:ring-2 hover:ring-indigo-400";
    const reach = isReach ? "ring-2 ring-indigo-500" : "";
    return `${base} ${size} ${bg} ${hover} ${reach}`;
  }

  function UnitBadge({ u }) {
    const t = UNIT_TYPES[u.type];
    const color = u.team === TEAM.RED.key ? TEAM.RED.color : TEAM.BLUE.color;
    const acted = u.acted ? "opacity-50" : "";
    return (
      <div className={`absolute inset-0 flex items-center justify-center ${acted}`}>
        <div className="flex flex-col items-center">
          <div className="rounded-full px-2 py-1 text-white text-xs" style={{ backgroundColor: color }}>
            {t.emoji}
          </div>
          <div className="mt-1 text-[10px] md:text-xs font-semibold">HP {u.hp}</div>
        </div>
      </div>
    );
  }

  function Sidebar() {
    const sel = selected;
    const myUnits = teamUnits(units, turn).length;
    const enemy = enemyUnits(units, turn).length;
    return (
      <div className="w-full md:w-64 p-3 md:p-4 bg-white/70 backdrop-blur rounded-2xl shadow space-y-3">
        <div className="flex items-center justify-between">
          <div className="text-sm md:text-base font-bold">Turn: <span className="px-2 py-0.5 rounded text-white" style={{backgroundColor: turn===TEAM.RED.key?TEAM.RED.color:TEAM.BLUE.color}}>{turn}</span></div>
          <button onClick={resetGame} className="text-xs md:text-sm px-2 py-1 rounded-lg border hover:bg-slate-50">Reset</button>
        </div>
        {winner ? (
          <div className="p-3 rounded-xl bg-lime-100 text-lime-900 font-semibold">Winner: {winner}</div>
        ) : (
          <button onClick={endTurn} className="w-full px-3 py-2 rounded-xl bg-indigo-600 text-white font-semibold hover:bg-indigo-700">End Turn</button>
        )}

        <div className="grid grid-cols-2 gap-2 text-xs">
          <div className="p-2 rounded-lg bg-red-50">Red: {turn===TEAM.RED.key?"(active) ":""}{turn===TEAM.RED.key?myUnits:enemy}</div>
          <div className="p-2 rounded-lg bg-blue-50">Blue: {turn===TEAM.BLUE.key?"(active) ":""}{turn===TEAM.BLUE.key?myUnits:enemy}</div>
        </div>

        <div className="text-sm md:text-base font-semibold">Selected</div>
        {sel ? (
          <div className="text-xs md:text-sm p-2 rounded-xl bg-slate-100 space-y-1">
            <div><b>{sel.team}</b> {UNIT_TYPES[sel.type].name}</div>
            <div>HP: {sel.hp}</div>
            <div>Move: {UNIT_TYPES[sel.type].move}</div>
            <div>Range: {UNIT_TYPES[sel.type].minRange}â€“{UNIT_TYPES[sel.type].maxRange}</div>
            <div>Status: {sel.acted ? "Done" : sel.moved ? "Moved" : phase}</div>
            <div>Pos: ({sel.x},{sel.y})</div>
            <div className="text-[11px] text-slate-600">Tip: ç§»å‹•å¾Œã«æ•µãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨æ”»æ’ƒã—ã¾ã™ã€‚ç©ºãƒã‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨è¡Œå‹•çµ‚äº†ã€‚</div>
          </div>
        ) : (
          <div className="text-xs md:text-sm p-2 rounded-xl bg-slate-50 text-slate-600">ãƒ¦ãƒ‹ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„</div>
        )}

        <div className="text-sm md:text-base font-semibold">Terrain legend</div>
        <div className="grid grid-cols-2 gap-2 text-xs">
          {TERRAIN_KEYS.map((k) => (
            <div key={k} className="p-2 rounded-lg bg-slate-50 flex items-center justify-between">
              <span>{TERRAIN[k].name}</span>
              <span className="text-slate-500">{TERRAIN[k].emoji}</span>
            </div>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen w-full bg-gradient-to-b from-sky-50 to-slate-100 p-3 md:p-6">
      <div className="mx-auto max-w-6xl grid grid-cols-1 md:grid-cols-[1fr_260px] gap-4">
        <div className="rounded-2xl bg-white p-2 md:p-4 shadow">
          <div className="text-base md:text-lg font-bold mb-2 md:mb-3">Battle Wars â€“ Mini</div>
          <div className="grid" style={{ gridTemplateColumns: `repeat(${W}, minmax(0,1fr))` }}>
            {Array.from({ length: H }).map((_, y) => (
              <React.Fragment key={`row-${y}`}>
                {Array.from({ length: W }).map((__, x) => {
                  const u = unitAt(units, x, y);
                  const t = grid[y][x];
                  return (
                    <div
                      key={`t-${x}-${y}`}
                      className={tileClasses(x, y)}
                      onClick={() => onTileClick(x, y)}
                      title={`${t.name}  DEF+${t.defense}  MC${t.moveCost}`}
                    >
                      <div className="absolute left-1 top-1 text-[10px] text-slate-500">{t.emoji}</div>
                      {u && <UnitBadge u={u} />}
                    </div>
                  );
                })}
              </React.Fragment>
            ))}
          </div>
          <div className="mt-3 text-xs md:text-sm text-slate-600">
            ä½¿ã„æ–¹ï¼šè‡ªè»ï¼ˆã‚¿ãƒ¼ãƒ³è¡¨ç¤ºã®è‰²ï¼‰ã®ãƒ¦ãƒ‹ãƒƒãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ â†’ é’ã„ãƒã‚¤ãƒ©ã‚¤ãƒˆã®ãƒã‚¹ã¸ç§»å‹• â†’ æ•µãƒ¦ãƒ‹ãƒƒãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ã§æ”»æ’ƒ â†’ ã€ŒEnd Turnã€ã§ç›¸æ‰‹ã¸äº¤ä»£ã€‚
          </div>
        </div>
        <Sidebar />
      </div>
    </div>
  );
}
