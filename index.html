<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>間違い探し（アニメ風・静止・超大きい間違い）</title>
<style>
  :root{
    --bg:#0b1020; --fg:#e6f3ff; --line:#22314f;
    --good:#23d18b; --bad:#ff4d6d; --hint:#f7b500;
  }
  html,body{margin:0;background:radial-gradient(1200px 600px at 50% 5%, #151d3f 0%, #0b1020 55%, #070a14 100%);
    color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif}
  .wrap{max-width:1280px;margin:0 auto;padding:14px}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  h1{font-size:clamp(18px,3vw,24px);letter-spacing:.06em;margin:6px 0}
  .btn{appearance:none;border:1px solid var(--line);background:#0e1836;color:var(--fg);
    border-radius:12px;padding:10px 16px;cursor:pointer;font-weight:600}
  .btn:hover{filter:brightness(1.08)}
  .pill{padding:6px 12px;border:1px solid var(--line);border-radius:999px;background:#0e1533;font-variant-numeric:tabular-nums}
  .boards{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
  .board{position:relative;border:1px solid var(--line);border-radius:14px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,.45);background:#0a122b}
  canvas{display:block;width:100%;height:auto}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;text-align:center;background:rgba(0,0,0,.45)}
  .card{background:rgba(8,12,28,.85);border:1px solid var(--line);border-radius:16px;padding:22px 20px;max-width:560px}
  footer{opacity:.75;font-size:12px;margin-top:10px;text-align:center}
  .shake{animation:shake .25s ease}
  @keyframes shake{
    0%{transform:translateX(0)} 25%{transform:translateX(-6px)}
    50%{transform:translateX(6px)} 75%{transform:translateX(-4px)} 100%{transform:translateX(0)}
  }
  .reticle{
    position:absolute; pointer-events:none; border:2px solid rgba(255,255,255,.45);
    border-radius:50%; width:56px; height:56px; transform:translate(-50%,-50%);
    box-shadow:0 0 0 2px rgba(0,0,0,.25) inset;
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>間違い探し（アニメ風・静止・超大きい間違い）</h1>
    <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
      <button id="startBtn" class="btn">▶ スタート</button>
      <button id="revealBtn" class="btn">👀 答えを見る</button>
      <span class="pill">残り: <b id="remain">-</b></span>
      <span class="pill">ミス: <b id="miss">0</b></span>
      <span class="pill">タイム: <b id="time">00:00</b></span>
    </div>
  </header>

  <div class="boards">
    <div class="board">
      <canvas id="canL"></canvas>
    </div>
    <div class="board" id="boardR">
      <canvas id="canR"></canvas>
      <div id="menu" class="overlay">
        <div class="card">
          <h2>遊び方</h2>
          <p>スタートで左右に「アニメ風の風景」を自動描画。右には<b>常に3か所</b>の<b>超大きい違い</b>を置きます。クリックで指定！</p>
          <p style="opacity:.85">開始直後3秒は、正解位置が薄く点滅して見つけやすいです。60秒 or ミス6回で自動的に答え表示。</p>
          <button id="startBig" class="btn">▶ スタート</button>
        </div>
      </div>
      <div id="ret" class="reticle" style="display:none"></div>
    </div>
  </div>

  <footer>© 2025 SpotDiff — Anime-style / Static / 3 big differences</footer>
</div>

<script>
(function(){
  const canL=document.getElementById('canL'), canR=document.getElementById('canR');
  const ctxL=canL.getContext('2d'), ctxR=canR.getContext('2d');
  const startBtn=document.getElementById('startBtn'), startBig=document.getElementById('startBig');
  const revealBtn=document.getElementById('revealBtn'), menu=document.getElementById('menu');
  const boardR=document.getElementById('boardR'), ret=document.getElementById('ret');
  const remainEl=document.getElementById('remain'), missEl=document.getElementById('miss'), timeEl=document.getElementById('time');

  const DIFF_COUNT=3, AUTO_REVEAL_TIME=60000, AUTO_REVEAL_MISS=6, NEAR_FACTOR=1.6;

  // 画像サイズ（描画ベース）は固定にして、毎回そのサイズで生成（“動き無し”）
  const IMG_W = 1280, IMG_H = 768;

  // 状態
  let diffs=[], found=0, missCount=0, revealed=false;
  let timerId=null, tStart=0, autoRevealTimer=null, introPulseUntil=0;

  function fmtTime(ms){const s=Math.floor(ms/1000);return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;}
  function startTimer(){clearInterval(timerId);tStart=performance.now();timerId=setInterval(()=>timeEl.textContent=fmtTime(performance.now()-tStart),250);
    clearTimeout(autoRevealTimer);autoRevealTimer=setTimeout(()=>revealAnswers(true),AUTO_REVEAL_TIME);}
  function stopTimer(){clearInterval(timerId);clearTimeout(autoRevealTimer);}

  function setupCanvas(canvas, ctx){
    const dpr=Math.min(window.devicePixelRatio||1,2);
    canvas.style.width=Math.min(640, IMG_W)+'px';
    const scale=IMG_W/IMG_H;
    const cssW=canvas.clientWidth||Math.min(640, IMG_W);
    const cssH=Math.round(cssW/scale);
    canvas.style.height=cssH+'px';
    canvas.width=Math.round(IMG_W*dpr);
    canvas.height=Math.round(IMG_H*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
  }

  // ===== アニメ風の風景を描く（画像不使用・Canvasのみ） =====
  function drawAnimeScene(ctx){
    const w=IMG_W, h=IMG_H;

    // 空（アニメ空っぽい2段グラデ）
    let g = ctx.createLinearGradient(0,0,0,h*0.7);
    g.addColorStop(0,'#87b9ff'); g.addColorStop(1,'#c9e6ff');
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h*0.7);

    // 地平線〜草地
    g = ctx.createLinearGradient(0,h*0.6,0,h);
    g.addColorStop(0,'#7ddc8a'); g.addColorStop(1,'#41b36c');
    ctx.fillStyle=g; ctx.fillRect(0,h*0.6,w,h*0.4);

    // 山並み（丸みを帯びた稜線）
    for(let i=0;i<3;i++){
      const baseY = h*0.62 + i*26;
      ctx.fillStyle = `hsl(${180+i*12}, 45%, ${35+i*6}%)`;
      ctx.beginPath();
      ctx.moveTo(0, baseY);
      for(let x=0;x<=w;x+=40){
        const y = baseY - 60*Math.sin((x/220)+(i*0.6)) - (i*12);
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h); ctx.lineTo(0, h); ctx.closePath(); ctx.fill();
    }

    // 太陽
    ctx.fillStyle = '#ffd36b';
    ctx.beginPath(); ctx.arc(w*0.78, h*0.2, 60, 0, Math.PI*2); ctx.fill();

    // 雲（フラット塗り＋角丸）
    function cloud(x,y,s){
      ctx.fillStyle='rgba(255,255,255,0.95)';
      roundedRect(x, y, 160*s, 48*s, 24*s, true);
      roundedRect(x+90*s, y-10*s, 130*s, 60*s, 28*s, true);
      roundedRect(x+40*s, y+6*s, 120*s, 38*s, 18*s, true);
    }
    cloud(120, 120, 1.0);
    cloud(420, 80, 1.2);
    cloud(740, 130, 0.9);

    // 桜の木っぽい（アニメ塗り）
    function sakura(x,y){
      ctx.fillStyle='#6a3f22'; ctx.fillRect(x-8,y,16,80);
      ctx.fillStyle='#ffbcd3';
      ctx.beginPath(); ctx.arc(x, y, 46, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(x+26, y+18, 34, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(x-28, y+10, 30, 0, Math.PI*2); ctx.fill();
    }
    sakura(180, h*0.6-20); sakura(280, h*0.6-10);

    // 鳥（記号的）
    ctx.strokeStyle='#274060'; ctx.lineWidth=3;
    for(let i=0;i<5;i++){
      const bx = 160 + i*120, by = 140 + (i%2)*16;
      ctx.beginPath(); ctx.moveTo(bx,by); ctx.quadraticCurveTo(bx+16,by-10, bx+32,by);
      ctx.moveTo(bx+32,by); ctx.quadraticCurveTo(bx+48,by-10, bx+64,by);
      ctx.stroke();
    }

    function roundedRect(x,y,w,h,r,fill){
      const rr=Math.min(r,w/2,h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      fill?ctx.fill():ctx.stroke();
    }
  }

  // 右側だけに「超大きい違い」を配置（3つ）
  function placeBigDifferences(ctx){
    const w=IMG_W, h=IMG_H;
    diffs = [];
    const RMIN=110, RMAX=160, MARGIN=160; // ★特大サイズ
    const shapes = ['star','heart','sunburst']; // アニメっぽい記号

    for(let i=0;i<DIFF_COUNT;i++){
      const r = Math.floor(RMIN + Math.random()*(RMAX-RMIN));
      const x = Math.floor(MARGIN + Math.random()*(w - MARGIN*2));
      const y = Math.floor(MARGIN + Math.random()*(h - MARGIN*2));
      const shape = shapes[i % shapes.length];
      diffs.push({x,y,r,found:false,shape});
      drawMarkerShape(ctx, shape, x, y, r); // 右だけ上描きで“違い”を作る
    }

    // 開始3秒だけ薄く点滅ヒント
    introPulseUntil = performance.now() + 3000;
  }

  // 差分本体（右に描く“目立つけど世界観なじむ”大きな形）
  function drawMarkerShape(ctx, shape, x, y, r){
    ctx.save();
    ctx.translate(x,y);
    if(shape==='star'){
      ctx.fillStyle='rgba(255,233,95,0.85)';
      star(0,0,r*0.9, Math.max(6, Math.floor(8)), 0.45);
      ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=4; ctx.stroke();
    }else if(shape==='heart'){
      ctx.fillStyle='rgba(255,120,145,0.85)';
      ctx.beginPath();
      heartPath(0,0,r*0.75); ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=4; ctx.stroke();
    }else{ // sunburst
      ctx.fillStyle='rgba(114,207,255,0.85)';
      sunburst(0,0,r*0.85,10);
      ctx.fill();
      ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.lineWidth=4; ctx.stroke();
    }
    ctx.restore();

    function star(cx,cy,R,points,inner=0.5){
      ctx.beginPath();
      for(let i=0;i<points*2;i++){
        const ang = Math.PI*i/points;
        const rr = (i%2===0)?R:(R*inner);
        const px = cx + rr*Math.cos(ang), py = cy + rr*Math.sin(ang);
        (i===0)?ctx.moveTo(px,py):ctx.lineTo(px,py);
      }
      ctx.closePath();
    }
    function heartPath(cx,cy,sz){
      const s = sz/16;
      ctx.moveTo(cx, cy+6*s);
      ctx.bezierCurveTo(cx-16*s, cy-10*s, cx-10*s, cy-26*s, cx, cy-18*s);
      ctx.bezierCurveTo(cx+10*s, cy-26*s, cx+16*s, cy-10*s, cx, cy+6*s);
    }
    function sunburst(cx,cy,R,n){
      ctx.beginPath();
      for(let i=0;i<n;i++){
        const ang = (i/n)*Math.PI*2;
        const rx = Math.cos(ang), ry = Math.sin(ang);
        ctx.moveTo(cx,cy);
        ctx.lineTo(cx+rx*R, cy+ry*R);
        ctx.arc(cx,cy,R, ang, ang + (Math.PI*2/n));
      }
      ctx.closePath();
    }
  }

  // 枠・ガイド
  function hintRings(ctx){
    if(performance.now() >= introPulseUntil || revealed) return;
    const a=0.18+0.12*Math.sin(performance.now()/160);
    ctx.save(); ctx.globalAlpha=a; ctx.lineWidth=8; ctx.strokeStyle='var(--hint)';
    diffs.forEach(d=>{ if(!d.found){ ctx.beginPath(); ctx.arc(d.x,d.y,d.r+18,0,Math.PI*2); ctx.stroke(); } });
    ctx.restore();
  }

  // 視覚フィードバック
  function pulseRing(ctx,x,y,r,color){
    ctx.save();
    ctx.lineWidth=10; ctx.strokeStyle=color;
    ctx.beginPath(); ctx.arc(x,y,r+20,0,Math.PI*2); ctx.stroke();
    ctx.restore();
  }
  function bigCross(ctx,x,y,size,color){
    const s=size;
    ctx.save();
    ctx.lineWidth=9; ctx.strokeStyle=color; ctx.globalAlpha=.95;
    ctx.beginPath(); ctx.moveTo(x-s,y-s); ctx.lineTo(x+s,y+s);
    ctx.moveTo(x+s,y-s); ctx.lineTo(x-s,y+s); ctx.stroke();
    ctx.restore();
  }
  function nearRing(ctx,x,y,r){
    ctx.save();
    ctx.lineWidth=8; ctx.setLineDash([14,12]); ctx.strokeStyle='var(--hint)';
    ctx.beginPath(); ctx.arc(x,y,r*NEAR_FACTOR,0,Math.PI*2); ctx.stroke();
    ctx.setLineDash([]); ctx.restore();
  }

  function revealAnswers(auto=false){
    stopTimer(); revealed=true;
    // 未発見をすべて強調
    ctxR.save(); ctxR.lineWidth=10; ctxR.strokeStyle='var(--hint)'; ctxR.globalAlpha=.95;
    diffs.forEach(d=>{ if(!d.found){ ctxR.beginPath(); ctxR.arc(d.x,d.y,d.r+22,0,Math.PI*2); ctxR.stroke(); } });
    ctxR.restore();
    remainEl.textContent=0;
    setTimeout(()=>alert(auto?'時間/ミス上限で答えを表示しました。スタートで再挑戦できます。':'答えを表示しました。スタートで再挑戦できます。'),10);
  }

  function drawBoth(){
    // 左右とも同じ“アニメ風風景”
    drawAnimeScene(ctxL);
    drawAnimeScene(ctxR);
  }

  async function startGame(){
    menu.style.display='none';
    revealed=false; remainEl.textContent='-'; timeEl.textContent='00:00'; missEl.textContent='0';
    stopTimer();

    // キャンバス初期化
    setupCanvas(canL, ctxL);
    setupCanvas(canR, ctxR);

    // ベース描画
    drawBoth();

    // 右だけに大きい差分を置く
    placeBigDifferences(ctxR);

    // タイマー開始
    found=0; missCount=0;
    remainEl.textContent=(DIFF_COUNT-found);
    startTimer();

    // 開始直後ヒントの薄リング
    hintRings(ctxR);
  }

  function checkHit(px,py){
    // キャンバスの CSS→実座標変換（静止なので単純）
    const r=canR.getBoundingClientRect();
    const dpr=Math.min(window.devicePixelRatio||1,2);
    const scaleX=(canR.width/dpr)/r.width, scaleY=(canR.height/dpr)/r.height;
    const x=(px - r.left)*scaleX, y=(py - r.top)*scaleY;

    for(const d of diffs){
      const dist=Math.hypot(x-d.x, y-d.y);
      if(!d.found && dist<=d.r){
        d.found=true; found++;
        pulseRing(ctxR,d.x,d.y,d.r,'var(--good)');
        remainEl.textContent=(DIFF_COUNT-found);
        if(found===DIFF_COUNT){ stopTimer(); setTimeout(()=>alert('クリア！'),10); }
        return;
      }
      if(!d.found && dist<=d.r*NEAR_FACTOR){
        nearRing(ctxR,d.x,d.y,d.r);
        return;
      }
    }
    // 遠い＝ミス
    missCount++; missEl.textContent=missCount;
    bigCross(ctxR,x,y,34,'var(--bad)');
    boardR.classList.remove('shake'); void boardR.offsetWidth; boardR.classList.add('shake');
    if(missCount>=AUTO_REVEAL_MISS){ revealAnswers(true); }
  }

  // イベント
  canR.addEventListener('click', e=>checkHit(e.clientX,e.clientY), {passive:true});

  // 照準ガイド（任意）：マウス位置表示
  function moveReticle(e){
    const r=canR.getBoundingClientRect();
    const cx=(e.touches?e.touches[0].clientX:e.clientX);
    const cy=(e.touches?e.touches[0].clientY:e.clientY);
    if(cx<r.left||cx>r.right||cy<r.top||cy>r.bottom){ ret.style.display='none'; return; }
    ret.style.display='block';
    ret.style.left=(cx-r.left)+'px'; ret.style.top=(cy-r.top)+'px';
  }
  canR.addEventListener('mousemove',moveReticle,{passive:true});
  canR.addEventListener('mouseleave',()=>{ ret.style.display='none'; });
  canR.addEventListener('touchstart',moveReticle,{passive:true});
  canR.addEventListener('touchmove',moveReticle,{passive:true});

  // ボタン
  document.getElementById('startBtn').onclick=startGame;
  document.getElementById('revealBtn').onclick=()=>revealAnswers(false);
  document.getElementById('startBig').onclick=startGame;

  // 初期ガイド
  menu.style.display='flex';
})();
</script>
</body>
</html>
