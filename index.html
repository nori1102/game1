<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Othello（オセロ）</title>
  <style>
    :root{
      --bg:#0b1020;--panel:#121a33;--accent:#7aa2ff;--accent-2:#00d3a7;--grid:#1d274a;--black:#111;--white:#f6f7fb;--green:#1f6f43;--green-2:#2f8d58;--text:#e6e9ff;--muted:#a6b0d0;--warn:#ffb54b;--red:#ff6b6b
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 600px at 10% -20%, #1c2650 0%, #0b1020 60%), var(--bg);color:var(--text);font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial,"Noto Sans JP", 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol';}
    a{color:var(--accent)}
    .app{max-width:1000px;margin:24px auto;padding:16px}

    .header{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between;margin-bottom:16px}
    .title{font-weight:800;letter-spacing:.2px;font-size:clamp(18px, 2.6vw, 26px)}
    .panel{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.04)), var(--panel);border:1px solid #26325f;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);}
    .controls{display:flex;gap:10px;flex-wrap:wrap;padding:12px}
    .btn{appearance:none;border:1px solid #2a3a70;background:#17234a;color:var(--text);padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer;transition:.15s transform,.15s background,.15s border-color;box-shadow:0 4px 14px rgba(0,0,0,.2)}
    .btn:hover{transform:translateY(-1px);background:#1b2a59;border-color:#3350a0}
    .btn:active{transform:translateY(0)}
    .btn.alt{background:#134b36;border-color:#1b6c4f}
    .btn.alt:hover{background:#176147;border-color:#238360}
    .btn.ghost{background:transparent;border-color:#374375}
    .btn.warn{background:#4a2b17;border-color:#7a4b28}
    .btn.warn:hover{background:#5b321a;border-color:#9a5f31}
    .btn[disabled]{opacity:.45;cursor:not-allowed;transform:none}

    .layout{display:grid;gap:16px;grid-template-columns:1fr;}
    @media (min-width: 960px){.layout{grid-template-columns: min(90vh,680px) 1fr}}

    .board-wrap{padding:16px}
    .board{aspect-ratio:1/1;width:100%;background:linear-gradient(180deg, rgba(0,0,0,.1), rgba(255,255,255,.06)),linear-gradient(45deg,#1b7b4c,#134f34);border-radius:18px;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);border:10px solid #0e3a24;box-shadow:inset 0 0 0 2px #0e3a24, 0 10px 30px rgba(0,0,0,.4)}
    .cell{position:relative;border:1.5px solid #0e3a24;background:linear-gradient(#218752,#1c6f44);display:flex;align-items:center;justify-content:center}
    .cell button{all:unset;position:absolute;inset:0;cursor:pointer}
    .cell button:focus-visible{outline:3px solid var(--accent);outline-offset:-6px;border-radius:6px}

    .disc{width:70%;height:70%;border-radius:50%;transform:scale(.9);transition:transform .18s ease, background .2s ease, box-shadow .2s ease;box-shadow:inset 6px 6px 10px rgba(0,0,0,.35), inset -4px -4px 8px rgba(255,255,255,.15), 0 6px 12px rgba(0,0,0,.35)}
    .disc.black{background:radial-gradient(circle at 35% 30%, #2b2b2b, #0b0b0b 70%)}
    .disc.white{background:radial-gradient(circle at 35% 30%, #fff, #cfd3da 70%)}
    .disc.place{transform:scale(1)}

    .hint::after{content:"";position:absolute;width:18%;height:18%;border-radius:50%;background:radial-gradient(circle at 50% 50%, rgba(255,255,255,.8), rgba(255,255,255,.0) 70%);box-shadow:0 0 0 2px rgba(255,255,255,.25) inset}
    .hint.black::after{box-shadow:0 0 0 2px rgba(0,0,0,.35) inset}

    .sidebar{padding:14px 16px;display:flex;flex-direction:column;gap:14px}
    .stat{display:flex;align-items:center;gap:10px}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;background:#0f1836;border:1px solid #27346a;font-weight:700}
    .badge .dot{width:14px;height:14px;border-radius:50%}
    .dot.black{background:#0b0b0b;box-shadow:inset 3px 3px 7px rgba(255,255,255,.08)}
    .dot.white{background:#f6f7fb;border:1px solid rgba(0,0,0,.2);box-shadow:inset 3px 3px 7px rgba(0,0,0,.15)}

    .info{color:var(--muted);line-height:1.6}
    .score{font-size:28px;font-weight:900;letter-spacing:.5px}
    .turn{font-weight:800}

    .history{max-height:280px;overflow:auto;border-top:1px dashed #2a3562;padding-top:8px}
    .move-line{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:13px;opacity:.9}

    .footer{opacity:.7;text-align:center;font-size:12px;padding:10px}
  </style>
</head>
<body>
  <div class="app">
    <div class="header">
      <div class="title">Othello（オセロ） – GitHub Pages 用 index.html</div>
      <div class="panel controls" role="toolbar" aria-label="ゲーム操作">
        <button class="btn" id="restartBtn" title="新しく開始">リスタート</button>
        <button class="btn ghost" id="undoBtn" title="一手戻す（Undo）">一手戻す</button>
        <button class="btn alt" id="aiToggleBtn" title="白をCPUにする/やめる">白：CPU</button>
        <button class="btn warn" id="clearStorageBtn" title="保存データを削除">保存クリア</button>
      </div>
    </div>

    <div class="layout">
      <div class="panel board-wrap">
        <div class="board" id="board" role="grid" aria-label="オセロ盤 8x8"></div>
      </div>

      <aside class="panel sidebar">
        <div class="stat">
          <span class="badge"><span class="dot black" aria-hidden="true"></span>黒：<span id="blackScore">2</span></span>
          <span class="badge"><span class="dot white" aria-hidden="true"></span>白：<span id="whiteScore">2</span></span>
        </div>
        <div class="score" id="scoreText">2 - 2</div>
        <div class="turn" id="turnText">手番：黒</div>
        <div class="info" id="statusText">合法手は緑マスのドットで表示されます。置けない場合は自動的にパスします。</div>

        <div>
          <div style="font-weight:800;margin-bottom:6px">棋譜 / 手一覧</div>
          <div id="history" class="history" aria-live="polite"></div>
        </div>
        <div class="footer">© Othello index.html – フロントのみ・保存は localStorage</div>
      </aside>
    </div>
  </div>

  <script>
  (()=>{
    const SIZE = 8;
    const EMPTY = 0, BLACK = 1, WHITE = -1;

    // 盤評価（簡易） – 角・辺を高評価
    const WEIGHTS = [
      [120,-20, 20,  5,  5, 20,-20,120],
      [-20,-40, -5, -5, -5, -5,-40,-20],
      [ 20, -5, 15,  3,  3, 15, -5, 20],
      [  5, -5,  3,  1,  1,  3, -5,  5],
      [  5, -5,  3,  1,  1,  3, -5,  5],
      [ 20, -5, 15,  3,  3, 15, -5, 20],
      [-20,-40, -5, -5, -5, -5,-40,-20],
      [120,-20, 20,  5,  5, 20,-20,120]
    ];

    const boardEl = document.getElementById('board');
    const blackScoreEl = document.getElementById('blackScore');
    const whiteScoreEl = document.getElementById('whiteScore');
    const scoreTextEl = document.getElementById('scoreText');
    const turnTextEl = document.getElementById('turnText');
    const statusTextEl = document.getElementById('statusText');
    const historyEl = document.getElementById('history');

    const restartBtn = document.getElementById('restartBtn');
    const undoBtn = document.getElementById('undoBtn');
    const aiToggleBtn = document.getElementById('aiToggleBtn');
    const clearStorageBtn = document.getElementById('clearStorageBtn');

    // 状態
    let state = {
      board: createInitialBoard(),
      player: BLACK,
      history: [], // {boardJSON, player, move}
      aiWhite: true
    };

    // localStorage から復元
    function hasAnyDisc(b){
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if(b[r][c]!==EMPTY) return true;
      return false;
    }
    const saved = localStorage.getItem('othello_state_v1');
    if(saved){
      try{ state = JSON.parse(saved); }catch(e){}
    }
    // 初回表示で石が無い（または壊れた保存データ）の場合は初期配置で開始
    if(!saved || !state || !Array.isArray(state.board) || !hasAnyDisc(state.board)){
      state = { board: createInitialBoard(), player: BLACK, history: [], aiWhite: true };
      localStorage.setItem('othello_state_v1', JSON.stringify(state));
    }

    buildBoardCells();
    render();
    setTimeout(()=>setStatus('新しいゲームを開始しました。黒の手番です。'), 0);

    restartBtn.addEventListener('click', ()=>{ reset(); });
    undoBtn.addEventListener('click', ()=>{ undo(); });
    aiToggleBtn.addEventListener('click', ()=>{ state.aiWhite = !state.aiWhite; save(); render(); maybeAIMove(); });
    clearStorageBtn.addEventListener('click', ()=>{ localStorage.removeItem('othello_state_v1'); setStatus('保存データを削除しました。'); });

    function createInitialBoard(){
      const b = Array.from({length: SIZE}, ()=> Array(SIZE).fill(EMPTY));
      b[3][3] = WHITE; b[3][4] = BLACK; b[4][3] = BLACK; b[4][4] = WHITE;
      return b;
    }

    function cloneBoard(b){ return b.map(row=>row.slice()); }

    function buildBoardCells(){
      boardEl.innerHTML = '';
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.setAttribute('role','gridcell');

          const btn = document.createElement('button');
          btn.setAttribute('aria-label', `r${r+1} c${c+1}`);
          btn.addEventListener('click', ()=> onCellClick(r,c));

          cell.appendChild(btn);
          boardEl.appendChild(cell);
        }
      }
    }

    function inBounds(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }

    const DIRS = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];

    function getValidMoves(b, player){
      const moves = [];
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          if(b[r][c] !== EMPTY) continue;
          const flipsAll = [];
          for(const [dr,dc] of DIRS){
            let rr=r+dr, cc=c+dc, line=[];
            while(inBounds(rr,cc) && b[rr][cc] === -player){
              line.push([rr,cc]); rr+=dr; cc+=dc;
            }
            if(line.length && inBounds(rr,cc) && b[rr][cc] === player){
              flipsAll.push(...line);
            }
          }
          if(flipsAll.length) moves.push({r,c, flips:flipsAll});
        }
      }
      return moves;
    }

    function applyMove(b, move, player){
      const nb = cloneBoard(b);
      nb[move.r][move.c] = player;
      for(const [r,c] of move.flips){ nb[r][c] = player; }
      return nb;
    }

    function countDiscs(b){
      let black=0, white=0;
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        if(b[r][c] === BLACK) black++; else if(b[r][c] === WHITE) white++;
      }
      return {black, white};
    }

    function coordToHuman(r,c){
      const cols = 'ABCDEFGH';
      return cols[c] + (r+1);
    }

    function pushHistory(move){
      state.history.push({ boardJSON: JSON.stringify(state.board), player: state.player, move });
      if(state.history.length>200) state.history.shift();
    }

    function undo(){
      const last = state.history.pop();
      if(!last) { setStatus('戻れる手がありません。'); return; }
      state.board = JSON.parse(last.boardJSON);
      state.player = last.player;
      save();
      render();
    }

    function reset(){
      state.board = createInitialBoard();
      state.player = BLACK;
      state.history = [];
      save();
      render();
      setStatus('新しいゲームを開始しました。黒の手番です。');
    }

    function gameOverMessage(){
      const {black, white} = countDiscs(state.board);
      if(black>white) return `ゲーム終了：黒の勝ち（${black}-${white}）`;
      if(white>black) return `ゲーム終了：白の勝ち（${white}-${black}）`;
      return `ゲーム終了：引き分け（${black}-${white}）`;
    }

    function onCellClick(r,c){
      const moves = getValidMoves(state.board, state.player);
      const m = moves.find(m=>m.r===r && m.c===c);
      if(!m){ setStatus('そこには置けません。'); return; }
      pushHistory({r,c});
      state.board = applyMove(state.board, m, state.player);
      state.player = -state.player;
      save();
      render();
      // パス判定とゲーム終了
      handlePassAndMaybeAIMove();
    }

    function handlePassAndMaybeAIMove(){
      let moves = getValidMoves(state.board, state.player);
      if(moves.length===0){
        // パス
        state.player = -state.player;
        save();
        render();
        const nextMoves = getValidMoves(state.board, state.player);
        if(nextMoves.length===0){
          setStatus(gameOverMessage());
          return; // ゲーム終了
        }else{
          setStatus('置ける場所がないためパスしました。');
        }
      }
      maybeAIMove();
    }

    function maybeAIMove(){
      if(state.aiWhite && state.player === WHITE){
        // ほんの少し待機して人間らしさを演出
        setTimeout(()=>{
          const move = chooseAIMove(state.board, WHITE);
          if(!move){ // 念のため
            state.player = -state.player; render(); return;
          }
          pushHistory(move);
          state.board = applyMove(state.board, move, WHITE);
          state.player = BLACK;
          save(); render();
          // 連続パスやゲーム終了チェック
          const moves = getValidMoves(state.board, state.player);
          if(moves.length===0){
            state.player = WHITE; render();
            const next = getValidMoves(state.board, state.player);
            if(next.length===0){ setStatus(gameOverMessage()); }
            else setStatus('黒が置けないためパス。');
          }
        }, 350);
      }
    }

    function evaluateBoard(b, player){
      // 石差 + 重み合計（プレイヤー視点）
      let score = 0;
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++){
        if(b[r][c] === player) score += 5 + WEIGHTS[r][c];
        else if(b[r][c] === -player) score -= 5 + WEIGHTS[r][c];
      }
      return score;
    }

    function chooseAIMove(b, player){
      const moves = getValidMoves(b, player);
      if(moves.length===0) return null;
      // 1手先読み + 盤面評価（簡易）
      let best = moves[0], bestScore = -Infinity;
      for(const m of moves){
        const nb = applyMove(b, m, player);
        const score = evaluateBoard(nb, player);
        // 角優先の微調整
        if((m.r===0||m.r===SIZE-1) && (m.c===0||m.c===SIZE-1)){
          // corners are powerful
          m._score = score + 200;
        }else{
          m._score = score;
        }
        if(m._score > bestScore){ bestScore = m._score; best = m; }
      }
      return best;
    }

    function setStatus(msg){ statusTextEl.textContent = msg; }

    function save(){ localStorage.setItem('othello_state_v1', JSON.stringify(state)); }

    function render(){
      // 盤面
      const cells = boardEl.children;
      const moves = getValidMoves(state.board, state.player);
      const hintSet = new Set(moves.map(m=>m.r+','+m.c));
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          const idx = r*SIZE + c;
          const cell = cells[idx];
          cell.classList.remove('hint','black','white');
          const btn = cell.querySelector('button');
          btn.disabled = false;
          cell.innerHTML = '';
          cell.appendChild(btn);
          const v = state.board[r][c];
          if(v===BLACK||v===WHITE){
            const d = document.createElement('div');
            d.className = 'disc ' + (v===BLACK?'black':'white') + ' place';
            cell.appendChild(d);
            btn.setAttribute('aria-label', `${v===BLACK?'黒':'白'}の石 r${r+1} c${c+1}`);
            btn.disabled = true; // 既に石がある
          }else{
            // ヒント
            if(hintSet.has(r+','+c)){
              cell.classList.add('hint', state.player===BLACK?'black':'white');
              btn.setAttribute('aria-label', `置けます r${r+1} c${c+1}`);
            }else{
              btn.setAttribute('aria-label', `空マス r${r+1} c${c+1}`);
            }
          }
        }
      }

      // スコア
      const {black, white} = countDiscs(state.board);
      blackScoreEl.textContent = black; whiteScoreEl.textContent = white;
      scoreTextEl.textContent = `${black} - ${white}`;
      turnTextEl.textContent = `手番：${state.player===BLACK?'黒':'白'}${state.aiWhite && state.player===WHITE?'（CPU）':''}`;

      // AI トグルラベル
      aiToggleBtn.textContent = `白：${state.aiWhite? 'CPU':'人'}`;

      // 棋譜
      historyEl.innerHTML = '';
      state.history.forEach((h, i)=>{
        const line = document.createElement('div');
        const m = h.move ? `${coordToHuman(h.move.r, h.move.c)}` : '';
        line.className='move-line';
        line.textContent = `${String(i+1).padStart(2,'0')}. ${h.player===BLACK?'黒':'白'} ${m}`;
        historyEl.appendChild(line);
      });

      // 保存
      save();

      // 合法手がない && 相手もない → 終了
      const myMoves = getValidMoves(state.board, state.player);
      const oppMoves = getValidMoves(state.board, -state.player);
      if(myMoves.length===0 && oppMoves.length===0){ setStatus(gameOverMessage()); }
    }

    // 初回、AI番なら動く
    maybeAIMove();
  })();
  </script>
</body>
</html>
