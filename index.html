<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>間違い探し（3か所固定・大きめ＆アニメベース）</title>
<style>
  :root{
    --bg:#0b1020; --fg:#e6f3ff; --line:#22314f;
    --good:#23d18b; --bad:#ff4d6d; --hint:#f7b500;
  }
  html,body{margin:0;background:radial-gradient(1200px 600px at 50% 5%, #151d3f 0%, #0b1020 55%, #070a14 100%);
    color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif}
  .wrap{max-width:1280px;margin:0 auto;padding:14px}
  header{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  h1{font-size:clamp(18px,3vw,24px);letter-spacing:.06em;margin:6px 0}
  .btn{appearance:none;border:1px solid var(--line);background:#0e1836;color:var(--fg);
    border-radius:12px;padding:10px 16px;cursor:pointer;font-weight:600}
  .btn:hover{filter:brightness(1.08)}
  .pill{padding:6px 12px;border:1px solid var(--line);border-radius:999px;background:#0e1533;font-variant-numeric:tabular-nums}
  .boards{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
  .board{position:relative;border:1px solid var(--line);border-radius:14px;overflow:hidden;box-shadow:0 10px 40px rgba(0,0,0,.45);background:#0a122b}
  canvas{display:block;width:100%;height:auto}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;text-align:center;background:rgba(0,0,0,.45)}
  .card{background:rgba(8,12,28,.85);border:1px solid var(--line);border-radius:16px;padding:22px 20px;max-width:560px}
  footer{opacity:.75;font-size:12px;margin-top:10px;text-align:center}
  .shake{animation:shake .25s ease}
  @keyframes shake{
    0%{transform:translateX(0)} 25%{transform:translateX(-6px)}
    50%{transform:translateX(6px)} 75%{transform:translateX(-4px)} 100%{transform:translateX(0)}
  }
  .reticle{
    position:absolute; pointer-events:none; border:2px solid rgba(255,255,255,.45);
    border-radius:50%; width:56px; height:56px; transform:translate(-50%,-50%);
    box-shadow:0 0 0 2px rgba(0,0,0,.25) inset;
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>間違い探し（3か所固定・大きめ＆アニメベース）</h1>
    <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
      <button id="startBtn" class="btn">▶ スタート</button>
      <button id="revealBtn" class="btn">👀 答えを見る</button>
      <span class="pill">残り: <b id="remain">-</b></span>
      <span class="pill">ミス: <b id="miss">0</b></span>
      <span class="pill">タイム: <b id="time">00:00</b></span>
    </div>
  </header>

  <div class="boards">
    <div class="board">
      <canvas id="canL"></canvas>
    </div>
    <div class="board" id="boardR">
      <canvas id="canR"></canvas>
      <div id="menu" class="overlay">
        <div class="card">
          <h2>遊び方</h2>
          <p>スタートでWEBから高精細画像を左右に表示。右には<b>常に3か所</b>の違いを仕込みます。クリックで指定！</p>
          <p style="opacity:.85">開始直後3秒は薄い点滅ヒント。60秒 or ミス6回で自動的に答えを表示します。</p>
          <button id="startBig" class="btn">▶ スタート</button>
        </div>
      </div>
      <div id="ret" class="reticle" style="display:none"></div>
    </div>
  </div>

  <footer>© 2025 SpotDiff — 3 differences / Random web image / Client-only</footer>
</div>

<script>
(function(){
  const canL=document.getElementById('canL'), canR=document.getElementById('canR');
  const ctxL=canL.getContext('2d'), ctxR=canR.getContext('2d');
  const startBtn=document.getElementById('startBtn'), startBig=document.getElementById('startBig');
  const revealBtn=document.getElementById('revealBtn'), menu=document.getElementById('menu');
  const boardR=document.getElementById('boardR'), ret=document.getElementById('ret');
  const remainEl=document.getElementById('remain'), missEl=document.getElementById('miss'), timeEl=document.getElementById('time');

  const DIFF_COUNT=3, AUTO_REVEAL_TIME=60000, AUTO_REVEAL_MISS=6, NEAR_FACTOR=1.6;

  // 画像＆オフスク
  let img=new Image(), offL=null, offR=null, imgW=0, imgH=0;
  // 状態
  let diffs=[], found=0, missCount=0, revealed=false;
  let timerId=null, tStart=0, autoRevealTimer=null, introPulseUntil=0;
  // アニメ（Ken Burns）
  const anim={s:1, tx:0, ty:0, t0:performance.now()};
  let rafId=null;

  function fmtTime(ms){const s=Math.floor(ms/1000);return `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;}
  function startTimer(){clearInterval(timerId);tStart=performance.now();timerId=setInterval(()=>timeEl.textContent=fmtTime(performance.now()-tStart),250);
    clearTimeout(autoRevealTimer);autoRevealTimer=setTimeout(()=>revealAnswers(true),AUTO_REVEAL_TIME);}
  function stopTimer(){clearInterval(timerId);clearTimeout(autoRevealTimer);}

  function setCanvasToImageSize(img, canvas, ctx){
    const dpr=Math.min(window.devicePixelRatio||1,2);
    canvas.style.width=Math.min(640,img.naturalWidth)+'px';
    const scale=img.naturalWidth/img.naturalHeight;
    const cssW=canvas.clientWidth||Math.min(640,img.naturalWidth);
    const cssH=Math.round(cssW/scale);
    canvas.style.height=cssH+'px';
    canvas.width=Math.round(img.naturalWidth*dpr);
    canvas.height=Math.round(img.naturalHeight*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
  }

  async function fetchRandomImage(){
    const api='https://commons.wikimedia.org/w/api.php';
    const url=`${api}?action=query&generator=random&grnnamespace=6&grnlimit=1&prop=imageinfo&iiprop=url|mime|size&iiurlwidth=3000&format=json&origin=*`;
    const res=await fetch(url); const data=await res.json();
    const page=data?.query?.pages && Object.values(data.query.pages)[0]; const info=page?.imageinfo?.[0];
    if(!info?.url) throw new Error('画像取得に失敗'); return info.url;
  }

  function buildOffscreens(){
    offL=document.createElement('canvas'); offR=document.createElement('canvas');
    offL.width=imgW; offL.height=imgH; offR.width=imgW; offR.height=imgH;
    offL.getContext('2d').drawImage(img,0,0); offR.getContext('2d').drawImage(img,0,0);
  }

  // 右画像へ「大きな」違いを埋め込む
  function implantDifferences(){
    diffs=[];
    // さらに倍：半径 80〜140px
    const RMIN=80, RMAX=140, MARGIN=120;
    for(let i=0;i<DIFF_COUNT;i++){
      const r=Math.floor(RMIN+Math.random()*(RMAX-RMIN));
      const x=Math.floor(MARGIN+Math.random()*(imgW-MARGIN*2));
      const y=Math.floor(MARGIN+Math.random()*(imgH-MARGIN*2));
      diffs.push({x,y,r,found:false});
    }
    const ctx=offR.getContext('2d');
    const data=ctx.getImageData(0,0,imgW,imgH), arr=data.data;

    function inCircle(cx,cy,cr,px,py){const dx=px-cx, dy=py-cy; return dx*dx+dy*dy<=cr*cr;}
    function rgb2hsl(r,g,b){r/=255;g/=255;b/=255;const max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,l=(max+min)/2;
      if(max===min){h=s=0;}else{const d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return[h,s,l];}
    function hsl2rgb(h,s,l){function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3 - t)*6;return p;}
      let r,g,b;if(s===0){r=g=b=l;}else{const q=l<0.5?l*(1+s):l+s-l*s,p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return[Math.round(r*255),Math.round(g*255),Math.round(b*255)];}

    diffs.forEach((d,idx)=>{
      const hueShift=((idx+1)*0.12)*(Math.random()<0.5?-1:1); // ±約43°
      const lightDelta=(Math.random()*0.30-0.15);             // 明るさ±0.15
      const satDelta=(Math.random()*0.45-0.22);               // 彩度±0.22
      for(let py=d.y-d.r; py<=d.y+d.r; py++){
        if(py<0||py>=imgH) continue;
        for(let px=d.x-d.r; px<=d.x+d.r; px++){
          if(px<0||px>=imgW) continue;
          if(!inCircle(d.x,d.y,d.r,px,py)) continue;
          const i=(py*imgW+px)*4; const r=arr[i], g=arr[i+1], b=arr[i+2];
          let [hh,ss,ll]=rgb2hsl(r,g,b);
          hh=(hh+hueShift+1)%1; ll=Math.max(0,Math.min(1,ll+lightDelta)); ss=Math.max(0,Math.min(1,ss+satDelta));
          const [nr,ng,nb]=hsl2rgb(hh,ss,ll); arr[i]=nr; arr[i+1]=ng; arr[i+2]=nb;
        }
      }
    });
    ctx.putImageData(data,0,0);

    found=0; missCount=0; revealed=false;
    remainEl.textContent=(DIFF_COUNT-found); missEl.textContent=missCount;
    introPulseUntil=performance.now()+3000; // 開始3秒ヒント
    startTimer();
  }

  // === アニメーション描画（Ken Burns＋オーバーレイも同変換で描画） ===
  function drawSide(ctx, off){
    const dpr=Math.min(window.devicePixelRatio||1,2);
    const w=canL.width/dpr, h=canL.height/dpr; // 両キャンバス同サイズ＝画像原寸
    const t=(performance.now()-anim.t0)/1000;
    // ゆるいズーム＆パン
    anim.s=1.02+0.02*Math.sin(t/1.8);
    anim.tx=Math.sin(t/2.4)*12;
    anim.ty=Math.cos(t/3.0)*8;

    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(imgW/2+anim.tx, imgH/2+anim.ty);
    ctx.scale(anim.s, anim.s);
    ctx.drawImage(off, -imgW/2, -imgH/2);
    ctx.restore();
  }

  // エフェクト描画（画像座標で管理→同じ変換で重ね描画）
  const effects=[]; // {type:'pulse'|'cross'|'near'|'reveal', x,y,r, life(0..1)}
  function addEffect(e){effects.push(e);}
  function drawEffects(ctx){
    const dpr=Math.min(window.devicePixelRatio||1,2);
    const w=canR.width/dpr, h=canR.height/dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.save();
    ctx.translate(imgW/2+anim.tx, imgH/2+anim.ty);
    ctx.scale(anim.s, anim.s);

    // 開始ヒント（時間内だけ薄い点滅）
    if(performance.now() < introPulseUntil && !revealed){
      const a=0.18+0.12*Math.sin(performance.now()/160);
      diffs.forEach(d=>{
        if(d.found) return;
        ctx.save(); ctx.lineWidth=6; ctx.globalAlpha=a; ctx.strokeStyle='var(--hint)';
        ctx.beginPath(); ctx.arc(d.x,d.y,d.r+14,0,Math.PI*2); ctx.stroke(); ctx.restore();
      });
    }

    // 常時の「答え表示」
    if(revealed){
      diffs.forEach(d=>{
        if(!d.found){
          ctx.save(); ctx.lineWidth=8; ctx.globalAlpha=.95; ctx.strokeStyle='var(--hint)';
          ctx.beginPath(); ctx.arc(d.x,d.y,d.r+16,0,Math.PI*2); ctx.stroke(); ctx.restore();
        }
      });
    }

    // 一時エフェクト
    for(let i=effects.length-1;i>=0;i--){
      const e=effects[i];
      if(e.type==='pulse'){
        const rr=e.r + (1-e.life)*40; const a=e.life*0.9;
        ctx.save(); ctx.lineWidth=10; ctx.globalAlpha=a; ctx.strokeStyle='var(--good)';
        ctx.beginPath(); ctx.arc(e.x,e.y,rr,0,Math.PI*2); ctx.stroke(); ctx.restore();
      }else if(e.type==='cross'){
        const s=28+(1-e.life)*12; const a=.95*e.life;
        ctx.save(); ctx.lineWidth=8; ctx.globalAlpha=a; ctx.strokeStyle='var(--bad)';
        ctx.beginPath(); ctx.moveTo(e.x-s,e.y-s); ctx.lineTo(e.x+s,e.y+s);
        ctx.moveTo(e.x+s,e.y-s); ctx.lineTo(e.x-s,e.y+s); ctx.stroke(); ctx.restore();
      }else if(e.type==='near'){
        const a=.7*e.life;
        ctx.save(); ctx.lineWidth=7; ctx.globalAlpha=a; ctx.setLineDash([12,10]); ctx.strokeStyle='var(--hint)';
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r*NEAR_FACTOR,0,Math.PI*2); ctx.stroke(); ctx.setLineDash([]); ctx.restore();
      }
      e.life -= 0.06;
      if(e.life<=0) effects.splice(i,1);
    }

    ctx.restore();
  }

  function loop(){
    if(!offL||!offR) return;
    drawSide(ctxL, offL);
    drawSide(ctxR, offR);
    drawEffects(ctxR);
    rafId=requestAnimationFrame(loop);
  }

  // クリック→キャンバス座標→画像座標へ逆変換
  function canvasToImageCoords(xc,yc){
    const cx=imgW/2, cy=imgH/2;
    const xi = ((xc - (cx + anim.tx)) / anim.s) + cx;
    const yi = ((yc - (cy + anim.ty)) / anim.s) + cy;
    return {x:xi, y:yi};
  }

  function revealAnswers(auto=false){
    stopTimer(); revealed=true;
    remainEl.textContent=0;
    setTimeout(()=>alert(auto?'時間/ミス上限で答えを表示しました。スタートで再挑戦できます。':'答えを表示しました。スタートで再挑戦できます。'),10);
  }

  async function startGame(){
    menu.style.display='none';
    revealed=false; effects.length=0;
    remainEl.textContent='-'; timeEl.textContent='00:00'; missEl.textContent='0';
    stopTimer(); if(rafId) cancelAnimationFrame(rafId);

    try{
      const src=await fetchRandomImage();
      img=new Image(); img.crossOrigin="anonymous";
      img.onload=()=>{
        imgW=img.naturalWidth; imgH=img.naturalHeight;
        setCanvasToImageSize(img, canL, ctxL);
        setCanvasToImageSize(img, canR, ctxR);
        buildOffscreens();
        implantDifferences();
        anim.t0=performance.now();
        loop();
      };
      img.src=src;
    }catch(e){
      console.error(e); alert('画像の取得に失敗しました。もう一度スタートしてください。');
      menu.style.display='flex';
    }
  }

  function checkHit(px,py){
    const pt=canvasToImageCoords(px,py);
    for(const d of diffs){
      const dist=Math.hypot(pt.x-d.x, pt.y-d.y);
      if(!d.found && dist<=d.r){
        d.found=true; found++;
        addEffect({type:'pulse', x:d.x, y:d.y, r:d.r, life:1});
        remainEl.textContent=(DIFF_COUNT-found);
        if(found===DIFF_COUNT){ stopTimer(); setTimeout(()=>alert('クリア！'),10); }
        return;
      }
      if(!d.found && dist<=d.r*NEAR_FACTOR){ // ニアミスはガイドのみ
        addEffect({type:'near', x:d.x, y:d.y, r:d.r, life:1});
        return;
      }
    }
    // 遠い＝ミス
    missCount++; missEl.textContent=missCount;
    addEffect({type:'cross', x:pt.x, y:pt.y, life:1});
    boardR.classList.remove('shake'); void boardR.offsetWidth; boardR.classList.add('shake');
    if(missCount>=AUTO_REVEAL_MISS){ revealAnswers(true); }
  }

  canR.addEventListener('click', e=>{
    const r=canR.getBoundingClientRect();
    const dpr=Math.min(window.devicePixelRatio||1,2);
    const scaleX=canR.width/dpr/r.width, scaleY=canR.height/dpr/r.height;
    const x=(e.clientX-r.left)*scaleX, y=(e.clientY-r.top)*scaleY;
    checkHit(x,y);
  }, {passive:true});

  // 照準（見た目ガイド）
  function moveReticle(e){
    const r=canR.getBoundingClientRect();
    const cx=(e.touches?e.touches[0].clientX:e.clientX);
    const cy=(e.touches?e.touches[0].clientY:e.clientY);
    if(cx<r.left||cx>r.right||cy<r.top||cy>r.bottom){ ret.style.display='none'; return; }
    ret.style.display='block';
    ret.style.left=(cx-r.left)+'px'; ret.style.top=(cy-r.top)+'px';
  }
  canR.addEventListener('mousemove',moveReticle,{passive:true});
  canR.addEventListener('mouseleave',()=>{ ret.style.display='none'; });
  canR.addEventListener('touchstart',moveReticle,{passive:true});
  canR.addEventListener('touchmove',moveReticle,{passive:true});

  startBtn.onclick=startGame; startBig.onclick=startGame;
  revealBtn.onclick=()=>revealAnswers(false);

  menu.style.display='flex';
})();
</script>
</body>
</html>
